https://scrumguides.org/docs/scrumguide/v2020/2020-Scrum-Guide-Portuguese-European.pdf

https://www.perforce.com/blog/hns/4-product-backlog-prioritization-techniques-work#stack


### Priority:

## MoSCoW:

    Must Have 4 — If you would have to cancel your release if you couldn’t include it, then it’s a Must Have. Must-Have user stories are those that you guarantee to deliver because you can’t deliver without, or it would be illegal or unsafe without. If there’s any way to deliver without it — a workaround, for example — then it should be downgraded to Should Have or Could Have. That doesn’t mean it won’t be delivered. It means that that delivery is not guaranteed.

    Should Have 3 — Should Have features are important, but notabsolutely vital to the success of your release. They can be painful to leave out, and may have an impact on your product, but they don’t affect minimum viability of your product.

    Could Have 2 — Could Have items are those that are wanted or desirable but are less important than a Should Have item. Leaving them out will cause less pain than a Should Have item.  

    Won’t Have 1 — Won’t Have user stories are those in which everyone has agreed not to deliver this time around. You may keep it in the backlog for later, if or when it becomes necessary to do so.

## Kano Model

    The Kano model was developed in the 1980s by Professor Noriaki Kano. Under the Kano Model, features are categorized according to needs and expectations of customers. There are a variety of versions of the Kano model. The original, however, classifies items using five thresholds: Must-be, Attractive, One-Dimensional, Indifferent, and Reverse.

    Must-Be — These are expected by your customers. They are features that will not WOW them. They must be included in your product, and are often taken for granted.

    One-Dimensional — These are features that make users happy when they’re there, unhappy when they’re not.
        
    Attractive — These make users happy when they’re there, but don’t disappoint them when they’re not.


    Indifferent — These have no impact on customer satisfaction levels. For example, refactoring parts of your code so that it is easier to read and understand. There is no direct value to the customer, but it will make it easier for you to maintain in the future.

    Reverse — These make users unhappy when they’re there, happy when they’re not. For example, you might implement high-security features requiring an extra step to login. However, if customers do not value enhanced security, they will become dissatisfied with the extra step.

type: User stories, Bugs, Technical tasks, Improvements, Research
    
    User stories: User stories are short, simple descriptions of a feature or requirement from the perspective of an end user. They are typically written in the format "As a [user], I want [functionality], so that [benefit]."

    Bugs: Bugs are issues or defects that need to be fixed in the product. These can include problems with the functionality, usability, or performance of the product.

    Technical tasks: Technical tasks are items that need to be completed in order to support the development of the product. These can include tasks such as refactoring code, updating documentation, or implementing new tools or frameworks.

    Improvements: Improvements are items that aim to enhance the product or user experience. These can include items like new features, usability enhancements, or performance improvements.

    Research items: Research items are items that need to be completed in order to gain knowledge or information that is needed to support the development of the product. These can include tasks such as market research, user research, or feasibility studies.

area: chassi, mcu, rasp_pi, eltro, devops, management
    management: Chores are small but necessary tasks or activities that are required to keep the development process running smoothly. Examples of Chores could be like updating the version control, cleaning up the code, etc.
cost_of_delay: 
    Linear — For every day we do not deliver, we lose some money. A common example of a linear cost of delay is money lost due to competitors already having a feature that you don’t.

    Fixed date — If we don’t deliver by a certain date, it’s too late. An example: let’s imagine you’re making New Year cards for 2019. If you don’t deliver them before the end of 2018, the cost of delay is very high. In fact, delivering afterward, in January or February, makes no difference — it is too late!

    Intangible — We can delay for now at minimal cost, but eventually it could become expensive. A good example is the cost of delay for fixing a few bugs or refactoring your code. You can skip today, but over time it will make other improvements more expensive and can cause the cost of delay to increase exponentially.

    Expedite — It must be done immediately or the cost of delay will grow radically. An example of an expedite feature is a severe bug that renders your product useless to all your customers. 


     